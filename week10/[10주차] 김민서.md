# [10주차] 김민서

생성자: 민서 김
생성 일시: 2023년 11월 28일 오후 7:45

## DOM과 Virtual Dom이란?

DOM : Doucument Object Model (문서 객체 모델) 이다.

DOM은 **XML이나 HTML 문서에 접근하기 위한 일종의 인터페이스**이며 각각의 요소에 대한 접근 방법을 제공한다.

DOM은 **계층구조**로 표현된다

![image](https://github.com/COW-edu/COW-React-2/assets/101965138/88a23c13-83e4-47fb-9dd5-1f82464d0cfd)
DOM은 브라우저에서 로드되며, 노드들로 이뤄진 트리인 것을 확인 할 수 있다.

노드는 무엇인가? HTML태그로 보인다. 

여기서 주의해야 할 것은 HTML이 DOM이라는 것이 아니다.

HTML은 VS코드에 입력한 자체로는 **그저 String인 문자열일 뿐**이다. 

우리가 작성한 HTML코드를 확인 하기 위해서는 반드시 브라우저가 필요하다. 

그리고 DOM은 브라우저에서 로드된다. 이러한 DOM은 자바스크립트로 해당 문서 객체 모델에 노드를 추가하거나 삭제, 변경, 이벤트 등을 가능케 하는 API를 제공한다.

**결론적으로 DOM은 내가 작성한 HTML코드를 브라우저와 자바스크립트가 이해할 수 있도록 객체로 변환시켜주는 역할을 한다.**

DOM이 브라우저에서 로드된다 했는데 브라우저는 어떻게 동작하는가?

### 브라우저의 동작 원리

![image](https://github.com/COW-edu/COW-React-2/assets/101965138/f20413c1-1605-4e96-bdb7-0c06bf26e1a7)

HTML이 우선 parser되고 이 html들을 DOM이 DOM Tree로 만든다.

그 뒤에 외부 CSS파일과 각 노드에 개별적으로 붙어있는 inline style들을 파싱하고 
DOM Tree와 Style Rules를 부착하여 Render Tree를 만든다.

Render Tree가 만들어진 시점에는 각 노드들이 정확히 어디에 나타나야하는지 위치가 주어지고 그 뒤 paint()메소드를 통해서 브라우저에 내가 구현한 코드의 화면이 출력되는 것이다.

---

## SPA vs MPA, SSR vs CSR 장단점 뜻 정리

**CSR(Clienet Side Rendering)**

렌더링이 클라이언트쪽에서 발생한다. 즉, 서버는 요청을 받으면 클라이언트에게 html과 js를 보내준다. 클라이언트는 그것을 받아 렌더링을 시작한다.

최초 한번 서버에서 전체 페이지(일반적으로 페이지 하나)를 로딩하여 보여주고 이후에는 사용자 요청이 올 때마다 리소스를 서버에 제공 한 뒤 클라이언트가 해석하고 다시 렌더링 하는 방식이다.

![image](https://github.com/COW-edu/COW-React-2/assets/101965138/68b191d9-4952-49fc-9531-565fddcca569)

1. 클라이언트가 요청을 보낸다
2. CDN(서버)가 HTML과 JS로 접근할 수 있는 링크를 보낸다
3. 브라우저는 이를 다운받는다 (최초 한번 서버에서 전체 페이지를 로딩하고 보여주기 때문에 이때 클라이언트는 아무것도 할 수 없다)
4. 다운이 완료되면 유저들은 placeholder를 보게되고 필요한 api가 호출된다 (특정 부분에 실제 데이터가 들어갈 자리에 "로딩 중..." 또는 예상 데이터의 형식을 보여주는 것이 placeholder의 역할)
5. 서버가 api호출에 응답한다
6. api로 받아온 data를 placeholder 자리에 넣어준다. 이제 상호작용이 가능한 페이지가 된다.

**SSR(Server Side Rendering)**

서버 사이드 렌더링. 말 그대로 서버에서 렌더링 준비를 끝마친 상태로 클라이언트에 전달 한다.

웹의 시작에 MPA 가 있었다.(하단 참조) MPA는 페이지를 이동할 때 마다 새로운 페이지를 요청한다 . 모든 템플릿은 서버를 통해서 연산되고 렌더링하고 완성된 페이지 형태로 응답한다.

![image](https://github.com/COW-edu/COW-React-2/assets/101965138/2b3da1cb-af3c-4625-aa0a-565f4b4be5ba)

1. 클라이언트가 요청을 보낸다
2. 서버는 즉시 렌더링 가능한 HTML파일을 만든다(리소스 체크, 컴파일 후 완성된 HTML컨텐츠를 만든다)
3. 클라이언트에 전달되는 순간 즉시 HTML이 렌더링 된다 (자바스크립트는 읽히기 전이므로 페이지 조작은 불가능)
4. 클라이언트가 자바스크립트를 다운
5. 다운 받아지고 있는 사이에 유저는 컨텐츠를 볼수 있지만 사이트 조작은 불가능하다. BUT 이때 사용자의 조작은 기억하고 있는다
6. 브라우저가 자바스크립트 프레임워크실행
7. 웹페이지 상호작용 가능

---

## SPA MPA

### **SPA**

한 개의 페이지로 구성된 APPLICATION을 의미

SPA는 CSR방식으로 렌더링 한다(**모든 SPA가 CSR방식으로 렌더링 하는 것은 아니다**)

CSR 방식의 설명대로 최초 한번 서버에서 하나의 페이지에 대한(HTML,CSS JS)를 불러오고 로딩한다. 그 후에는 데이터를 받아올때만 서버와 통신한다. 기존페이지를 수정하는 방식

**SPA 장점**

1. 자연스러운 페이지 전환 (전체 페이지를 업데이트 하는 방식이 아니라 깜빡이지 않아서 자연스러움)
2. 필요한 리소스만 부분적으로 로딩하기 때문에 성능면에서 이점이 있다
3. 컴포넌트 개발이 용이하다
4. 서버의 템플릿 연산을 클라이언트로 분산 (csr 방식이기 때문에 렌더링을 클라이언트가 해서 서버의 부담이 줄어는 다는 뜻)
5. 모바일 앱 개발을 염두에 둔다면 동일 api를 사용하도록 설계할 수 있다. (웹 과 앱에서 동일 api를 사용가능하다는 말 같다)

**SPA 단점**

JavaScript 파일을 번들링해서 한 번에 받기 때문에 초기 구동 속도가 느리다. (Webpack의 code splitting으로 해결 가능), 그리고 필요한 HTML,CSS,JS를 한꺼번에 다운 받아 두기 때문에 느리기도 하다. (CSR의 특징)
검색엔진최적화(SEO)가 어려움 (SSR로 해결 가능)
보안 이슈 (프론트엔드에 비즈니스 로직 최소화)
SSR에서는 사용자에 대한 정보를 서버 측에서 세션으로 관리를 하지만 CSR 방식에서는 클라이언트측의 쿠키말고는 사용자에 대한 정보를 저장할 공간이 마땅치 않다

### **MPA**

SPA와 반대로 여러 개의 페이지로 구성된 Application이다

MPA는 SSR방식으로 렌더링 된다. 

새로운 페이지를 요청할 때마다 서버에서 이미 렌더링 된 HTML CSS JS를 다운로드 한다.

(그래서 서버에서 렌더링 된 코드를 다운로드해서 첫 페이지는 빠름. 페이지 이동 시에 또 다운로드 해서 페이지 전환이 잦으면 불리하다) 

**MPA 장점**

SEO 관점에서 유리하다 (검색엔진)

MPA는 완성된 형태의 HTML을 서버로 부터 다운로드 받아서 검색엔진 크롤러한테 유리하다

반면에 SPA(CSR)은 초기에 빈 페이지에서 HTML과 CSS JS를 다운받아 브라우저에서 동적으로 생성되기 때문에 SEO가 힘들다

첫 로딩이 짧다. 서버에서 이미 렌더링 해서 가져오기 때문이다. 

**MPA 단점**

새로운 페이지로 이동 시 화면이 깜빡거린다. 

새로운 페이지를 요청할 때 마다 서버에서 렌더링된 파일을 다시 다운로드 받아오기 때문

페이지 이동 시 불필요한 템플릿도 중복해서 로딩(성능저하)

서버에서 렌더링 되기 때문에 서버에 부하

모바일 앱 개발 시 백엔드 작업이 추가적으로 필요하다.

---

## Virtual DOM이란?

![image](https://github.com/COW-edu/COW-React-2/assets/101965138/975ac5c1-e3a4-470c-b287-ec68a2a2f59e)

가상 DOM은 DOM이 생성되기 전, 이전 상태 값과 수정사항을 비교하여 달라진 부분만 DOM에게 한 번에 전달하여 **딱 한 번만 렌더링**을 진행한다. (CSR에서 주로 사용되는 기술인 것 같다)

![image]([https://github.com/COW-edu/COW-React-2/assets/101965138/d90b62fe-0b51-4224-827e-1511fa20bc57](https://github.com/COW-edu/COW-React-2/assets/101965138/d90b62fe-0b51-4224-827e-1511fa20bc57))

가상 DOM이 없었다면 DOM노드 트리의 전체가 빨간 노드로 변경이 이뤄지고 렌더링이 다시 되어야 했겠지만 가상DOM을 통해서 이전 상태 값과 수정사항을 비교해서 달라진 부분만 원래 DOM 한테 전달 한 것을 나타낸 그림이다.
